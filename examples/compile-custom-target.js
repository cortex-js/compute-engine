/**
 * Example: Creating a Custom Compilation Target
 *
 * This example demonstrates how to create a custom compilation target
 * using the exported CompileTarget interface and BaseCompiler.
 *
 * We'll create a simple "Calculator DSL" that compiles to function calls
 * with uppercase names, useful for interfacing with legacy systems or
 * domain-specific calculators.
 */

import {
  ComputeEngine,
  BaseCompiler,
  JavaScriptTarget,
} from '@cortex-js/compute-engine';

const ce = new ComputeEngine();

// ============================================================================
// Example 1: Using JavaScriptTarget as a Base
// ============================================================================
console.log('Example 1: Extending JavaScriptTarget');
console.log('='.repeat(70));

// Create a custom target that extends the JavaScript target
// with custom formatting for constants
const jsTarget = new JavaScriptTarget();
const customTarget = jsTarget.createTarget({
  // Override variable formatting
  var: (id) => {
    // Map common constants to uppercase
    const constants = {
      Pi: 'PI',
      ExponentialE: 'E',
      ImaginaryUnit: 'I',
    };
    if (id in constants) return constants[id];
    return `VAR_${id.toUpperCase()}`;
  },
  // Add custom preamble
  preamble: '// Generated by Custom Calculator DSL\n',
});

const expr1 = ce.parse('2\\pi + e');
const code1 = BaseCompiler.compile(expr1, customTarget);
console.log('Expression:', expr1.toString());
console.log('Compiled:', code1);
console.log();

// ============================================================================
// Example 2: Custom Target with Function Calls
// ============================================================================
console.log('Example 2: Custom Target with All Function Calls');
console.log('='.repeat(70));

// Create a target where ALL operations are function calls
// (useful for DSLs that don't support infix operators)
const functionTarget = {
  language: 'calculator-dsl',
  operators: (op) => {
    // Map all operators to uppercase function names
    const opMap = {
      Add: ['ADD', 11],
      Subtract: ['SUB', 11],
      Multiply: ['MUL', 12],
      Divide: ['DIV', 13],
      Power: ['POW', 14],
      Negate: ['NEG', 14],
      Equal: ['EQ', 8],
      Less: ['LT', 9],
      Greater: ['GT', 9],
    };
    return opMap[op];
  },
  functions: (id) => {
    // Map common functions to uppercase
    const fnMap = {
      Sin: 'SIN',
      Cos: 'COS',
      Tan: 'TAN',
      Sqrt: 'SQRT',
      Abs: 'ABS',
      Exp: 'EXP',
      Log: 'LOG',
      Ln: 'LN',
    };
    return fnMap[id];
  },
  var: (id) => `VAR("${id}")`,
  string: (s) => `"${s}"`,
  number: (n) => n.toString(),
  ws: () => ' ',
  preamble: '',
  indent: 0,
};

const expr2 = ce.parse('\\sin(x) + \\cos(y)^2');
const code2 = BaseCompiler.compile(expr2, functionTarget);
console.log('Expression:', expr2.toString());
console.log('Compiled:', code2);
console.log();

// ============================================================================
// Example 3: RPN (Reverse Polish Notation) Target
// ============================================================================
console.log('Example 3: Custom RPN (Reverse Polish Notation) Target');
console.log('='.repeat(70));

// Create a target that outputs RPN (like HP calculators)
// We'll use a custom compilation approach
class RPNTarget {
  constructor() {
    this.jsTarget = new JavaScriptTarget();
  }

  compile(expr) {
    // For RPN, we need to traverse the expression tree differently
    // This is a simplified example
    return this.compileToRPN(expr);
  }

  compileToRPN(expr) {
    if (expr.symbol) return expr.symbol;
    if (expr.isNumberLiteral) return expr.re.toString();

    const op = expr.operator;
    const args = expr.ops || [];

    // Compile arguments first (postorder traversal)
    const compiledArgs = args.map((arg) => this.compileToRPN(arg));

    // Map operators to RPN commands
    const opMap = {
      Add: '+',
      Subtract: '-',
      Multiply: '*',
      Divide: '/',
      Power: '^',
      Sin: 'SIN',
      Cos: 'COS',
      Sqrt: 'SQRT',
    };

    const rpnOp = opMap[op] || op;

    // In RPN: operands first, then operator
    return `${compiledArgs.join(' ')} ${rpnOp}`;
  }
}

const rpnTarget = new RPNTarget();
const expr3 = ce.parse('(3 + 4) * 5');
const rpn = rpnTarget.compile(expr3);
console.log('Expression:', expr3.toString());
console.log('RPN:', rpn);
console.log('(Stack-based evaluation: push 3, push 4, add, push 5, multiply)');
console.log();

// ============================================================================
// Example 4: SQL-like Target
// ============================================================================
console.log('Example 4: SQL-like Expression Target');
console.log('='.repeat(70));

// Create a target for SQL-like expressions
const sqlTarget = {
  language: 'sql',
  operators: (op) => {
    const opMap = {
      Add: ['+', 11],
      Subtract: ['-', 11],
      Multiply: ['*', 12],
      Divide: ['/', 13],
      Equal: ['=', 8],
      NotEqual: ['<>', 8],
      Less: ['<', 9],
      Greater: ['>', 9],
      LessEqual: ['<=', 9],
      GreaterEqual: ['>=', 9],
      And: ['AND', 4],
      Or: ['OR', 3],
      Not: ['NOT', 14],
    };
    return opMap[op];
  },
  functions: (id) => {
    const fnMap = {
      Abs: 'ABS',
      Sqrt: 'SQRT',
      Power: 'POWER',
      Ceiling: 'CEILING',
      Floor: 'FLOOR',
      Round: 'ROUND',
    };
    return fnMap[id];
  },
  var: (id) => `"${id}"`, // Quote column names
  string: (s) => `'${s.replace(/'/g, "''")}'`, // SQL string escaping
  number: (n) => n.toString(),
  ws: () => ' ',
  preamble: '',
  indent: 0,
};

const expr4 = ce.parse('x > 10 \\land y \\leq 20');
const sql = BaseCompiler.compile(expr4, sqlTarget);
console.log('Expression:', expr4.toString());
console.log('SQL WHERE clause:', `WHERE ${sql}`);
console.log();

// ============================================================================
// Example 5: Pretty-Print Target with Indentation
// ============================================================================
console.log('Example 5: Pretty-Print Target with Indentation');
console.log('='.repeat(70));

// Create a target that pretty-prints with indentation
const prettyTarget = {
  language: 'pretty',
  operators: (op) => {
    const opMap = {
      Add: ['add', 11],
      Multiply: ['multiply', 12],
      Power: ['power', 14],
    };
    return opMap[op];
  },
  functions: (id) => id.toLowerCase(),
  var: (id) => id,
  string: (s) => `"${s}"`,
  number: (n) => n.toString(),
  ws: (s) => {
    if (s === '\n') return '\n  '; // Add indentation
    return s || '';
  },
  preamble: '',
  indent: 0,
};

const expr5 = ce.parse('(a + b) * (c + d)');
const pretty = BaseCompiler.compile(expr5, prettyTarget);
console.log('Expression:', expr5.toString());
console.log('Pretty-printed:');
console.log(pretty);
console.log();

// ============================================================================
// Summary
// ============================================================================
console.log('Summary');
console.log('='.repeat(70));
console.log('✓ Extended JavaScriptTarget with custom variable mapping');
console.log('✓ Created all-function-call target for legacy systems');
console.log('✓ Implemented custom RPN compilation');
console.log('✓ Created SQL-like expression target');
console.log('✓ Built pretty-print target with formatting');
console.log();
console.log('The CompileTarget interface enables:');
console.log('  • Custom operator and function mappings');
console.log('  • Domain-specific language generation');
console.log('  • Code generation for external systems');
console.log('  • Alternative evaluation strategies');
